"""
Checkpointer Adapter for {{ goal_id }}

Auto-generated by GoalGen
Creates backend-specific checkpointer with StateManager integration
"""

from typing import Dict, Any, Optional
import os
import logging
from langgraph.checkpoint.memory import MemorySaver

{% if schema_migrations %}
from .schema_migrations import migrate_state, CURRENT_SCHEMA_VERSION
{% endif %}

logger = logging.getLogger(__name__)

# Fallback imports - use memory checkpointer if frmk modules not available
try:
    from frmk.core.state_manager import create_state_manager
    from frmk.core.tracked_checkpointer import create_tracked_checkpointer
    {% if checkpointing_backend == 'cosmos' %}
    from frmk.checkpointers.cosmos_checkpointer import CosmosCheckpointer
    {% elif checkpointing_backend == 'redis' %}
    from frmk.checkpointers.redis_checkpointer import RedisCheckpointer
    {% elif checkpointing_backend == 'blob' %}
    from frmk.checkpointers.blob_checkpointer import BlobCheckpointer
    {% endif %}
    FRMK_AVAILABLE = True
except ImportError as e:
    logger.warning(f"frmk modules not fully available: {e}. Using MemorySaver fallback.")
    FRMK_AVAILABLE = False


def create_checkpointer(goal_config: Dict[str, Any]):
    """
    Create checkpointer with StateManager tracking

    Backend: {{ checkpointing_backend }}

    Flow:
    1. Create underlying checkpointer (Cosmos/Redis/Blob/Memory)
    2. Create StateManager (handles conversation tracking + metrics)
    3. Wrap with TrackedCheckpointer (intercepts saves)
    4. Return tracked checkpointer to LangGraph

    Supports fallback to MemorySaver for local development.
    Set USE_MEMORY_CHECKPOINTER=true to use memory checkpointer.
    """

    checkpointing_config = goal_config.get("state_management", {}).get("checkpointing", {})
    backend = checkpointing_config.get("backend", "memory")

    # Check if using memory fallback
    use_memory = os.getenv("USE_MEMORY_CHECKPOINTER", "false").lower() == "true"

    if use_memory or not FRMK_AVAILABLE:
        logger.info("Using MemorySaver checkpointer (local development mode)")
        return MemorySaver()

    {% if checkpointing_backend == 'cosmos' %}
    # Cosmos DB Checkpointer
    cosmos_config = checkpointing_config.get("configuration", {}).get("cosmos", {})

    endpoint = cosmos_config.get("endpoint") or os.getenv("COSMOS_ENDPOINT")
    database = cosmos_config.get("database", "{{ goal_id }}_db")
    container = cosmos_config.get("container", "checkpoints")

    if not endpoint:
        logger.warning("Cosmos endpoint not configured, falling back to MemorySaver")
        return MemorySaver()

    underlying_checkpointer = CosmosCheckpointer(
        endpoint=endpoint,
        database=database,
        container=container
    )

    {% elif checkpointing_backend == 'redis' %}
    # Redis Checkpointer
    redis_config = checkpointing_config.get("configuration", {}).get("redis", {})

    connection_string = redis_config.get("connection_string") or os.getenv("REDIS_CONNECTION_STRING")

    if not connection_string:
        logger.warning("Redis connection string not configured, falling back to MemorySaver")
        return MemorySaver()

    underlying_checkpointer = RedisCheckpointer(
        connection_string=connection_string,
        key_prefix="{{ goal_id }}_checkpoints"
    )

    {% elif checkpointing_backend == 'blob' %}
    # Azure Blob Storage Checkpointer
    blob_config = checkpointing_config.get("configuration", {}).get("blob", {})

    connection_string = blob_config.get("connection_string") or os.getenv("BLOB_CONNECTION_STRING")
    container_name = blob_config.get("container", "{{ goal_id }}-checkpoints")

    if not connection_string:
        logger.warning("Blob connection string not configured, falling back to MemorySaver")
        return MemorySaver()

    underlying_checkpointer = BlobCheckpointer(
        connection_string=connection_string,
        container_name=container_name
    )

    {% else %}
    # In-memory checkpointer (dev/testing only)
    underlying_checkpointer = MemorySaver()
    {% endif %}

    # Create StateManager
    state_manager = create_state_manager(goal_config, underlying_checkpointer)

    # Wrap with tracking
    tracked_checkpointer = create_tracked_checkpointer(
        checkpointer=underlying_checkpointer,
        state_manager=state_manager,
        user_id_extractor=lambda config: config.get("configurable", {}).get("user_id", "unknown")
    )

    {% if schema_migrations %}
    # Wrap with migration support
    migrating_checkpointer = MigratingCheckpointer(tracked_checkpointer)
    return migrating_checkpointer
    {% else %}
    return tracked_checkpointer
    {% endif %}


{% if schema_migrations %}
class MigratingCheckpointer(BaseCheckpointSaver):
    """
    Checkpointer wrapper that automatically migrates state on load

    Implements lazy migration: state is migrated when loaded, not upfront.
    """

    def __init__(self, base_checkpointer: BaseCheckpointSaver):
        self.base_checkpointer = base_checkpointer

    async def aget(self, config: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Load checkpoint and migrate if needed"""

        checkpoint = await self.base_checkpointer.aget(config)

        if checkpoint is None:
            return None

        # Get state from checkpoint
        state = checkpoint.get("channel_values", {})
        state_version = state.get("schema_version", 1)

        # Migrate if needed
        if state_version < CURRENT_SCHEMA_VERSION:
            thread_id = config.get("configurable", {}).get("thread_id", "unknown")
            logger.info(
                f"Migrating checkpoint {thread_id} "
                f"from v{state_version} to v{CURRENT_SCHEMA_VERSION}"
            )

            migrated_state = migrate_state(state)
            checkpoint["channel_values"] = migrated_state

            # Optionally: Save migrated checkpoint back to storage
            # This makes future loads faster
            await self.aput(config, checkpoint, {})

        return checkpoint

    def get(self, config: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Sync version of aget (delegates to base)"""
        import asyncio
        return asyncio.run(self.aget(config))

    async def aput(self, config: Dict[str, Any], checkpoint: Dict[str, Any], metadata: Dict[str, Any]) -> None:
        """Save checkpoint (delegates to base)"""
        await self.base_checkpointer.aput(config, checkpoint, metadata)

    def put(self, config: Dict[str, Any], checkpoint: Dict[str, Any], metadata: Dict[str, Any]) -> None:
        """Sync version of aput (delegates to base)"""
        import asyncio
        asyncio.run(self.aput(config, checkpoint, metadata))

    async def alist(self, config: Dict[str, Any]) -> list:
        """List checkpoints (delegates to base)"""
        return await self.base_checkpointer.alist(config)

    def list(self, config: Dict[str, Any]) -> list:
        """Sync version of alist (delegates to base)"""
        import asyncio
        return asyncio.run(self.alist(config))
{% endif %}
