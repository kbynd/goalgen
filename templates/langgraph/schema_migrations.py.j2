"""
Schema Migrations for {{ goal_id }}

Auto-generated by GoalGen
Handles state schema version migrations

Current Schema Version: {{ schema_version | default(1) }}
{% if schema_migrations %}
Migrations Defined:
{% for migration_key in schema_migrations.keys() %}
  - {{ migration_key }}: {{ schema_migrations[migration_key].get('description', 'No description') }}
{% endfor %}
{% endif %}
"""

from typing import Dict, Any
import logging

logger = logging.getLogger(__name__)

# Current schema version (from spec)
CURRENT_SCHEMA_VERSION = {{ schema_version | default(1) }}


def migrate_state(state: Dict[str, Any]) -> Dict[str, Any]:
    """
    Migrate state from any version to current version

    Args:
        state: State dictionary (may be old version)

    Returns:
        Migrated state at current version
    """

    # Get current state version (default to 1 if not set)
    state_version = state.get("schema_version", 1)

    if state_version == CURRENT_SCHEMA_VERSION:
        # Already at current version
        return state

    logger.info(f"Migrating state from v{state_version} to v{CURRENT_SCHEMA_VERSION}")

    # Apply migrations sequentially
    migrated_state = state.copy()

    while state_version < CURRENT_SCHEMA_VERSION:
        next_version = state_version + 1
        migration_key = f"{state_version}_to_{next_version}"
        migration_fn = MIGRATIONS.get(migration_key)

        if migration_fn:
            migrated_state = migration_fn(migrated_state)
            migrated_state["schema_version"] = next_version
            logger.info(f"Applied migration {state_version} → {next_version}")
        else:
            logger.error(f"Missing migration {state_version} → {next_version}")
            break

        state_version = next_version

    return migrated_state


{% if schema_migrations %}
# Migration functions
{% for migration_key, migration_spec in schema_migrations.items() %}

def migrate_{{ migration_key }}(state: Dict[str, Any]) -> Dict[str, Any]:
    """
    Migration {{ migration_key }}: {{ migration_spec.get('description', 'No description') }}
    """

    {% set migration_type = migration_spec.get('migration', 'set_default') %}
    {% if migration_type == 'set_default' %}
    # Add new fields with default values
    {% if migration_spec.get('added_fields') %}
    {% for field_name in migration_spec.get('added_fields', []) %}
    if "{{ field_name }}" not in state:
        {% set default_val = migration_spec.get('default_values', {}).get(field_name) %}
        {% if default_val is none %}
        state["{{ field_name }}"] = None
        {% else %}
        state["{{ field_name }}"] = {{ default_val | tojson }}
        {% endif %}
    {% endfor %}
    {% endif %}

    {% elif migration_type == 'rename_field' %}
    # Rename fields
    {% if migration_spec.get('renamed_fields') %}
    {% for old_name, new_name in migration_spec.get('renamed_fields', {}).items() %}
    if "{{ old_name }}" in state:
        state["{{ new_name }}"] = state.pop("{{ old_name }}")
    {% endfor %}
    {% endif %}

    {% elif migration_type == 'remove_field' %}
    # Remove deprecated fields
    {% if migration_spec.get('removed_fields') %}
    {% for field_name in migration_spec.get('removed_fields', []) %}
    state.pop("{{ field_name }}", None)  # Safe removal
    {% endfor %}
    {% endif %}

    {% elif migration_type == 'transform' %}
    # Transform field types
    {% if migration_spec.get('transformed_fields') %}
    {% for field_name, transform_spec in migration_spec.get('transformed_fields', {}).items() %}
    if "{{ field_name }}" in state:
        # Custom transformation for {{ field_name }}
        # From: {{ transform_spec.get('from_type', 'unknown') }}
        # To: {{ transform_spec.get('to_type', 'unknown') }}

        # TODO: Implement custom transformation logic
        # This is a placeholder - customize based on your needs
        {% if transform_spec.get('transform_fn') %}
        # User requested transform function: {{ transform_spec.get('transform_fn') }}
        # Implement custom logic here
        {% endif %}
        pass
    {% endfor %}
    {% endif %}

    {% else %}
    # Custom migration type: {{ migration_type }}
    # TODO: Implement custom migration logic
    pass
    {% endif %}

    return state
{% endfor %}


# Migration registry
MIGRATIONS = {
    {% for migration_key in schema_migrations.keys() %}
    "{{ migration_key }}": migrate_{{ migration_key }},
    {% endfor %}
}
{% else %}
# No migrations defined - this is schema version 1
MIGRATIONS = {}
{% endif %}


def get_migration_path(from_version: int, to_version: int) -> list[str]:
    """
    Get the sequence of migrations needed to go from one version to another

    Args:
        from_version: Starting schema version
        to_version: Target schema version

    Returns:
        List of migration keys in order
    """

    if from_version >= to_version:
        return []

    path = []
    current = from_version

    while current < to_version:
        next_version = current + 1
        migration_key = f"{current}_to_{next_version}"

        if migration_key not in MIGRATIONS:
            raise ValueError(f"Missing migration: {migration_key}")

        path.append(migration_key)
        current = next_version

    return path


def validate_migration_chain() -> bool:
    """
    Validate that all migrations from v1 to current version exist

    Returns:
        True if migration chain is complete, False otherwise
    """

    try:
        path = get_migration_path(1, CURRENT_SCHEMA_VERSION)
        logger.info(f"Migration chain validated: {' → '.join(path)}")
        return True
    except ValueError as e:
        logger.error(f"Migration chain validation failed: {e}")
        return False
