"""
Microsoft Teams Bot for {{ goal_title }}

Integrates with Bot Framework SDK and LangGraph workflow via ConversationMapper.
"""

import os
import json
import logging
from typing import Dict, Any, Optional
from botbuilder.core import ActivityHandler, TurnContext, MessageFactory, CardFactory
from botbuilder.schema import Activity, ActivityTypes, ChannelAccount, Attachment
import httpx

# Import ConversationMapper from frmk
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent / "frmk"))

from frmk.conversation import create_conversation_mapper, ConversationContext
from frmk.utils.tracing import TraceSpan, start_trace, get_trace_id

from .config import Config

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class {{ goal_id.replace('_', ' ').title().replace(' ', '') }}Bot(ActivityHandler):
    """
    Teams Bot for {{ goal_title }}

    Handles conversation with Teams users and routes messages to LangGraph workflow.
    Uses ConversationMapper to maintain persistent conversation state across messages.
    """

    def __init__(self, config: Config):
        """
        Initialize bot with configuration

        Args:
            config: Bot configuration (API URLs, credentials, etc.)
        """
        self.config = config

        # Initialize ConversationMapper
        self.mapper = create_conversation_mapper(config.conversation_mapping_config)

{% if use_adaptive_cards %}
        # Load adaptive card templates
        self.cards_dir = Path(__file__).parent / "adaptive_cards"
        self._load_card_templates()

{% endif %}
        logger.info(f"Bot initialized: {{ goal_title }}")
        logger.info(f"LangGraph endpoint: {config.langgraph_api_url}")
        logger.info(f"Conversation mapping strategy: {config.conversation_mapping_config.get('strategy')}")

    async def on_message_activity(self, turn_context: TurnContext):
        """
        Handle incoming message from Teams user

        Args:
            turn_context: Bot Framework turn context with activity details
        """
        # Start trace for bot message handling
        trace_id = start_trace()
        span = TraceSpan("bot.on_message_activity", trace_id)
        span.add_metadata("component", "teams_bot")

        try:
            activity = turn_context.activity
            user_message = activity.text

            logger.info(f"Received message from {activity.from_property.name}: {user_message}")

            # Build conversation context from Teams activity
            context = self._build_conversation_context(activity)

            # Get thread_id for LangGraph using ConversationMapper
            result = self.mapper.get_thread_id(context)
            thread_id = result.thread_id

            if result.is_new:
                logger.info(f"New conversation started: {thread_id}")
            else:
                logger.info(f"Continuing conversation: {thread_id}")

            # Call LangGraph API with thread_id
            response_data = await self._call_langgraph_api(
                message=user_message,
                thread_id=thread_id,
                user_id=context.user_id,
                context=context
            )

            # Extract response message
            response_message = response_data.get("message", "I'm processing your request...")

{% if use_adaptive_cards %}
            # Send response as Adaptive Card (if enabled)
            response_card = self._create_response_card_from_template(response_message, activity)
            card_activity = MessageFactory.attachment(response_card)
            await turn_context.send_activity(card_activity)
{% else %}
            # Send plain text response
            await turn_context.send_activity(MessageFactory.text(response_message))
{% endif %}

            span.end()
            span.log()

            # Update activity timestamp (for database strategy)
            self.mapper.update_activity(thread_id)

        except Exception as e:
            span.end()
            span.add_metadata("error", str(e))
            span.log()
            logger.error(f"Error handling message: {e}", exc_info=True)
            error_message = "Sorry, I encountered an error processing your request. Please try again."
{% if use_adaptive_cards %}
            error_card = self._create_error_card_from_template(error_message, activity)
            card_activity = MessageFactory.attachment(error_card)
            await turn_context.send_activity(card_activity)
{% else %}
            await turn_context.send_activity(error_message)
{% endif %}

    async def on_members_added_activity(
        self,
        members_added: list[ChannelAccount],
        turn_context: TurnContext
    ):
        """
        Handle bot added to conversation

        Args:
            members_added: List of new members
            turn_context: Bot Framework turn context
        """
        for member in members_added:
            if member.id != turn_context.activity.recipient.id:
                # User added bot to conversation
                logger.info(f"Bot added to conversation by {member.name}")

{% if use_adaptive_cards %}
                # Send welcome message as Adaptive Card
                welcome_card = self._create_welcome_card_from_template(turn_context.activity)
                card_activity = MessageFactory.attachment(welcome_card)
                await turn_context.send_activity(card_activity)
{% else %}
                # Send plain text welcome message
                welcome_message = (
                    f"Hello! I'm {{ bot_name }}, your {{ goal_title }} assistant. "
                    f"How can I help you today?"
                )
                await turn_context.send_activity(welcome_message)
{% endif %}

    async def on_conversation_update_activity(self, turn_context: TurnContext):
        """
        Handle conversation lifecycle events (bot added/removed)

        Args:
            turn_context: Bot Framework turn context
        """
        activity = turn_context.activity

        # Handle bot removed from conversation
        if activity.members_removed:
            for member in activity.members_removed:
                if member.id == activity.recipient.id:
                    logger.info(f"Bot removed from conversation: {activity.conversation.id}")

                    # Deactivate conversation in mapper (if database strategy)
                    try:
                        context = self._build_conversation_context(activity)
                        result = self.mapper.get_thread_id(context)
                        self.mapper.deactivate_conversation(result.thread_id)
                    except Exception as e:
                        logger.error(f"Error deactivating conversation: {e}")

        # Call parent implementation
        await super().on_conversation_update_activity(turn_context)

    def _build_conversation_context(self, activity: Activity) -> ConversationContext:
        """
        Build ConversationContext from Teams Activity

        Args:
            activity: Bot Framework activity

        Returns:
            ConversationContext for ConversationMapper
        """
        # Use Azure AD Object ID if available (more stable)
        user_id = activity.from_property.aad_object_id or activity.from_property.id

        return ConversationContext(
            conversation_id=activity.conversation.id,
            user_id=user_id,
            conversation_type=activity.conversation.conversation_type,
            tenant_id=activity.conversation.tenant_id,
            user_name=activity.from_property.name,
            channel_id=activity.channel_data.get("channel", {}).get("id") if activity.channel_data else None,
            service_url=activity.service_url,
            metadata={
                "channel": activity.channel_id,
                "locale": activity.locale,
            }
        )

    async def _call_langgraph_api(
        self,
        message: str,
        thread_id: str,
        user_id: str,
        context: ConversationContext
    ) -> Dict[str, Any]:
        """
        Call LangGraph API with message and thread_id

        Args:
            message: User's message
            thread_id: LangGraph thread_id from ConversationMapper
            user_id: User's Azure AD Object ID
            context: Full conversation context

        Returns:
            Response data from LangGraph API

        Raises:
            httpx.HTTPError: If API call fails
        """
        url = f"{self.config.langgraph_api_url}/api/v1/message"

        payload = {
            "message": message,
            "thread_id": thread_id,
            "user_id": user_id,
            "metadata": {
                "conversation_type": context.conversation_type,
                "tenant_id": context.tenant_id,
                "channel": context.metadata.get("channel"),
            }
        }

        # Add trace ID to headers for distributed tracing
        headers = {}
        trace_id = get_trace_id()
        if trace_id:
            headers["X-Trace-Id"] = trace_id

        async with httpx.AsyncClient(timeout=self.config.langgraph_api_timeout) as client:
            response = await client.post(url, json=payload, headers=headers)
            response.raise_for_status()
            return response.json()

{% if use_adaptive_cards %}
    def _load_card_templates(self):
        """Load adaptive card templates from version-specific directories"""
        self.card_templates = {}
        try:
            # Load both v1.2 (emulator) and v1.4 (Teams) templates
            for version in ["v1.2", "v1.4"]:
                version_dir = self.cards_dir / version
                if not version_dir.exists():
                    continue

                for card_file in ["welcome.json", "response.json", "error.json"]:
                    card_path = version_dir / card_file
                    if card_path.exists():
                        with open(card_path) as f:
                            card_name = card_file.replace(".json", "")
                            # Store as "welcome_v12", "welcome_v14", etc.
                            template_key = f"{card_name}_{version.replace('.', '')}"
                            self.card_templates[template_key] = json.load(f)
                            logger.info(f"Loaded card template: {template_key}")
        except Exception as e:
            logger.warning(f"Error loading card templates: {e}")

    def _get_card_version(self, activity: Activity) -> str:
        """
        Detect appropriate Adaptive Card version based on channel

        Args:
            activity: Bot Framework activity

        Returns:
            Version string: "v12" (emulator) or "v14" (Teams)
        """
        # Emulator has limited support - use v1.2
        if activity.channel_id == "emulator":
            return "v12"
        # Teams supports latest features - use v1.4
        elif activity.channel_id == "msteams":
            return "v14"
        # Default to safe version for unknown channels
        return "v12"

    def _substitute_template_vars(self, template: Dict[str, Any], variables: Dict[str, str]) -> Dict[str, Any]:
        """
        Recursively substitute template variables in adaptive card JSON

        Args:
            template: Card template dictionary
            variables: Variables to substitute (e.g., {"${response}": "actual text"})

        Returns:
            Card with substituted variables
        """
        import copy
        card = copy.deepcopy(template)

        def substitute_recursive(obj):
            if isinstance(obj, dict):
                return {k: substitute_recursive(v) for k, v in obj.items()}
            elif isinstance(obj, list):
                return [substitute_recursive(item) for item in obj]
            elif isinstance(obj, str):
                result = obj
                for var, value in variables.items():
                    result = result.replace(var, value)
                return result
            else:
                return obj

        return substitute_recursive(card)

    def _create_welcome_card_from_template(self, activity: Activity) -> Attachment:
        """Create Adaptive Card for welcome message from template"""
        version = self._get_card_version(activity)
        template_key = f"welcome_{version}"

        if template_key in self.card_templates:
            card_content = self.card_templates[template_key]
        else:
            # Fallback if template not loaded
            card_content = {
                "type": "AdaptiveCard",
                "version": "1.2",
                "body": [
                    {
                        "type": "TextBlock",
                        "text": "üëã Welcome to {{ bot_name }}!",
                        "size": "Large",
                        "weight": "Bolder"
                    }
                ]
            }

        return CardFactory.adaptive_card(card_content)

    def _create_response_card_from_template(self, response: str, activity: Activity) -> Attachment:
        """Create Adaptive Card for response message from template"""
        version = self._get_card_version(activity)
        template_key = f"response_{version}"

        if template_key in self.card_templates:
            template = self.card_templates[template_key]
            card_content = self._substitute_template_vars(template, {"${response}": response})
        else:
            # Fallback if template not loaded
            card_content = {
                "type": "AdaptiveCard",
                "version": "1.2",
                "body": [
                    {
                        "type": "TextBlock",
                        "text": response,
                        "wrap": True
                    }
                ]
            }

        return CardFactory.adaptive_card(card_content)

    def _create_error_card_from_template(self, error_message: str, activity: Activity) -> Attachment:
        """Create Adaptive Card for error message from template"""
        version = self._get_card_version(activity)
        template_key = f"error_{version}"

        if template_key in self.card_templates:
            template = self.card_templates[template_key]
            card_content = self._substitute_template_vars(template, {"${errorMessage}": error_message})
        else:
            # Fallback if template not loaded
            card_content = {
                "type": "AdaptiveCard",
                "version": "1.2",
                "body": [
                    {
                        "type": "TextBlock",
                        "text": f"‚ö†Ô∏è Error: {error_message}",
                        "wrap": True,
                        "color": "Warning"
                    }
                ]
            }

        return CardFactory.adaptive_card(card_content)
{% endif %}
