"""
FastAPI Orchestrator for {{ goal_id }}

Auto-generated by GoalGen
"""

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
from typing import Dict, Any, Optional
import uuid
import os
from pathlib import Path
import sys

sys.path.insert(0, str(Path(__file__).parent.parent))

from workflow.quest_builder import graph
from frmk.utils.logging import get_logger
from frmk.utils.tracing import TraceSpan, start_trace

logger = get_logger("api")

app = FastAPI(
    title="{{ goal_title }}",
    description="{{ goal_description }}",
    version="1.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=os.getenv("CORS_ORIGINS", "*").split(","),
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


class MessageRequest(BaseModel):
    message: str = Field(..., description="User message")
    thread_id: Optional[str] = Field(None, description="Thread ID")
    user_id: Optional[str] = Field(None, description="User ID")


class MessageResponse(BaseModel):
    message: str
    thread_id: str
    context: Dict[str, Any] = Field(default_factory=dict)
    completed: bool = False


@app.get("/health")
async def health_check():
    return {"status": "healthy", "goal_id": "{{ goal_id }}"}


@app.post("/api/v1/message", response_model=MessageResponse)
async def send_message(request: MessageRequest):
    """Send message to workflow"""

    # Start trace
    trace_id = start_trace()
    span = TraceSpan("orchestrator.send_message", trace_id)
    span.add_metadata("component", "orchestrator")

    try:
        thread_id = request.thread_id or str(uuid.uuid4())
        user_id = request.user_id or "anonymous"

        span.add_metadata("thread_id", thread_id)
        logger.info(f"Message received: thread_id={thread_id}")

        initial_state = {
            "messages": [("user", request.message)],
            "context": {},
            "completed_tasks": [],
            "thread_id": thread_id,
            "user_id": user_id,
        }

        result = await graph.ainvoke(
            initial_state,
            config={
                "configurable": {
                    "thread_id": thread_id,
                    "user_id": user_id
                }
            }
        )

        messages = result.get("messages", [])
        last_message = messages[-1] if messages else None

        if last_message is None:
            raise HTTPException(status_code=500, detail="No response")

        if hasattr(last_message, "content"):
            response_text = last_message.content
        elif isinstance(last_message, tuple):
            response_text = last_message[1]
        else:
            response_text = str(last_message)

        context = result.get("context", {})
        required_fields = {{ context_fields | tojson }}
        completed = all(context.get(field) is not None for field in required_fields)

        span.end()
        span.log()

        return MessageResponse(
            message=response_text,
            thread_id=thread_id,
            context=context,
            completed=completed
        )

    except Exception as e:
        span.end()
        span.add_metadata("error", str(e))
        span.log()
        logger.error(f"Error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.on_event("startup")
async def startup_event():
    logger.info("Starting {{ goal_id }} API")


if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
