# Incremental Generation Design

How GoalGen handles adding new agents/tools to existing projects without breaking changes.

## Problem Statement

**Current behavior**: Running `goalgen.py` regenerates ALL files from scratch
- ❌ Overwrites manual changes
- ❌ Loses custom implementations
- ❌ Forces full regeneration every time

**Desired behavior**: Add new agents/tools without touching existing code
- ✅ Preserve manual edits
- ✅ Add only new components
- ✅ Update only affected files
- ✅ Safe incremental development

## Use Cases

### Use Case 1: Add New Agent

**Initial generation:**
```bash
# v1 spec: supervisor_agent + flight_agent
./goalgen.py --spec v1_spec.json --out ./my_project
```

**Generated:**
- `langgraph/agents/supervisor_agent.py`
- `langgraph/agents/flight_agent.py`
- `langgraph/agents/__init__.py`
- `langgraph/quest_builder.py` (references both agents)

**User customizes:**
```python
# User manually edits flight_agent.py
class FlightAgent(BaseAgent):
    async def invoke(self, state):
        # Custom implementation
        ...
```

**Add hotel agent:**
```bash
# v2 spec: supervisor_agent + flight_agent + hotel_agent
./goalgen.py --spec v2_spec.json --out ./my_project --incremental
```

**Expected behavior:**
- ✅ Add `langgraph/agents/hotel_agent.py` (new file)
- ✅ Update `langgraph/agents/__init__.py` (add hotel_agent import)
- ✅ Update `langgraph/quest_builder.py` (add hotel_agent node)
- ✅ Keep `flight_agent.py` unchanged (preserve custom code)
- ✅ Keep `supervisor_agent.py` unchanged

### Use Case 2: Add New Tool

**Initial:**
```json
{
  "tools": {
    "flight_api": { "type": "http", ... }
  }
}
```

**Add hotel API:**
```json
{
  "tools": {
    "flight_api": { "type": "http", ... },
    "hotel_api": { "type": "http", ... }  // New
  }
}
```

**Expected behavior:**
- ✅ Add `tools/hotel_api/function_app.py`
- ✅ Update tool registry in quest_builder.py
- ✅ Keep flight_api unchanged

### Use Case 3: Update Schema Version

**Initial v1:**
```json
{
  "schema_version": 1,
  "context_fields": ["destination"]
}
```

**Add field (v2):**
```json
{
  "schema_version": 2,
  "context_fields": ["destination", "budget"],
  "schema_migrations": {
    "1_to_2": { ... }
  }
}
```

**Expected behavior:**
- ✅ Update `langgraph/state_schema.py` (add budget field)
- ✅ Add/update `langgraph/schema_migrations.py` (add 1_to_2 migration)
- ✅ Keep existing agent implementations unchanged

## Solution Design

### Option 1: File Manifest Tracking (Recommended)

Track what was generated, detect changes, merge intelligently.

**Implementation:**
1. Generate `.goalgen/manifest.json` on first run
2. Track: filename, content_hash, user_modified flag
3. On subsequent runs:
   - Compare spec changes
   - Detect new/removed/modified components
   - Only regenerate affected files
   - Warn about conflicts

**Manifest structure:**
```json
{
  "generated_at": "2025-01-15T10:30:00Z",
  "spec_version": "1.0.0",
  "spec_hash": "abc123",
  "files": {
    "langgraph/agents/flight_agent.py": {
      "generated_at": "2025-01-15T10:30:00Z",
      "content_hash": "def456",
      "user_modified": false,
      "generator": "agents",
      "depends_on": ["agents.flight_agent"]
    },
    "langgraph/quest_builder.py": {
      "generated_at": "2025-01-15T10:30:00Z",
      "content_hash": "ghi789",
      "user_modified": true,
      "generator": "langgraph",
      "depends_on": ["agents.*", "tools.*"]
    }
  }
}
```

**CLI usage:**
```bash
# First time (creates manifest)
./goalgen.py --spec spec.json --out ./project

# Incremental update (uses manifest)
./goalgen.py --spec spec_v2.json --out ./project --incremental

# Force regenerate everything (ignores manifest)
./goalgen.py --spec spec.json --out ./project --force

# Preview changes (dry-run)
./goalgen.py --spec spec_v2.json --out ./project --incremental --dry-run
```

### Option 2: Smart Merge with User Regions

Mark regions in generated files as "user customizable":

```python
# Generated by GoalGen - DO NOT EDIT THIS LINE
class FlightAgent(BaseAgent):
    # GOALGEN_REGION_START: user_customizable
    async def invoke(self, state):
        # Add your custom logic here
        pass
    # GOALGEN_REGION_END: user_customizable
```

**Pros:**
- Clear boundaries
- Easy to preserve user code

**Cons:**
- Intrusive markers in code
- Limited flexibility

### Option 3: Component-Level Generation

Only regenerate specific components:

```bash
# Add just the hotel agent
./goalgen.py --spec spec.json --out ./project \
  --add-agent hotel_agent

# Add just a tool
./goalgen.py --spec spec.json --out ./project \
  --add-tool hotel_api

# Update schema only
./goalgen.py --spec spec.json --out ./project \
  --targets langgraph --component state_schema
```

**Pros:**
- Precise control
- No manifest needed

**Cons:**
- Complex CLI
- User needs to know what to update

## Recommended Implementation: Hybrid Approach

Combine **Option 1 (Manifest)** with **intelligent file comparison**:

### Phase 1: Manifest Generation

**File:** `.goalgen/manifest.json`

```python
# In goalgen.py
def generate_manifest(spec, out_dir, generated_files):
    manifest = {
        "version": "1.0",
        "generated_at": datetime.now().isoformat(),
        "spec": {
            "path": spec_path,
            "hash": hash_file(spec_path),
            "version": spec.get("version"),
            "schema_version": spec.get("schema_version", 1)
        },
        "files": {}
    }

    for file_path in generated_files:
        manifest["files"][file_path] = {
            "hash": hash_file(file_path),
            "generator": detect_generator(file_path),
            "created_at": datetime.now().isoformat()
        }

    manifest_path = Path(out_dir) / ".goalgen" / "manifest.json"
    manifest_path.parent.mkdir(exist_ok=True)
    manifest_path.write_text(json.dumps(manifest, indent=2))
```

### Phase 2: Incremental Mode

**New CLI flag:** `--incremental` or `--update`

```python
def main():
    parser.add_argument("--incremental", action="store_true",
                       help="Incremental update (preserve existing files)")

    args = parser.parse_args()

    if args.incremental:
        manifest = load_manifest(args.out)
        changed_components = detect_changes(manifest, spec)

        # Only regenerate changed components
        for component in changed_components:
            generate_component(component, spec, args.out)
    else:
        # Full generation (current behavior)
        generate_all(spec, args.out)
```

### Phase 3: Smart Merging

**For files that need updates (like quest_builder.py):**

```python
def merge_agent_nodes(existing_file, new_agents):
    """Add new agent nodes without removing existing ones"""

    tree = ast.parse(existing_file.read_text())

    # Find existing agent nodes
    existing_nodes = extract_agent_nodes(tree)

    # Add only new nodes
    for agent_name in new_agents:
        if agent_name not in existing_nodes:
            add_agent_node(tree, agent_name)

    # Write back
    existing_file.write_text(ast.unparse(tree))
```

## Implementation Plan

### Stage 1: Manifest Support (Day 2)

**Add to goalgen.py:**
- [ ] Generate `.goalgen/manifest.json` after each run
- [ ] Track generated files and content hashes
- [ ] Add `--incremental` flag
- [ ] Load and compare manifest

**Changes:**
```python
# In goalgen.py
from pathlib import Path
import hashlib
import json
from datetime import datetime

class GenerationManifest:
    def __init__(self, out_dir):
        self.manifest_path = Path(out_dir) / ".goalgen" / "manifest.json"
        self.manifest = self.load()

    def load(self):
        if self.manifest_path.exists():
            return json.loads(self.manifest_path.read_text())
        return {"version": "1.0", "files": {}}

    def save(self, spec, generated_files):
        manifest = {
            "version": "1.0",
            "generated_at": datetime.now().isoformat(),
            "spec_hash": self._hash_dict(spec),
            "files": {}
        }

        for file_path in generated_files:
            if Path(file_path).exists():
                manifest["files"][str(file_path)] = {
                    "hash": self._hash_file(file_path),
                    "timestamp": datetime.now().isoformat()
                }

        self.manifest_path.parent.mkdir(parents=True, exist_ok=True)
        self.manifest_path.write_text(json.dumps(manifest, indent=2))

    def _hash_file(self, path):
        return hashlib.sha256(Path(path).read_bytes()).hexdigest()

    def _hash_dict(self, d):
        return hashlib.sha256(json.dumps(d, sort_keys=True).encode()).hexdigest()

    def is_modified(self, file_path):
        """Check if file was modified by user"""
        file_path = str(file_path)
        if file_path not in self.manifest.get("files", {}):
            return False

        stored_hash = self.manifest["files"][file_path]["hash"]
        if not Path(file_path).exists():
            return False

        current_hash = self._hash_file(file_path)
        return stored_hash != current_hash
```

### Stage 2: Component Detection (Day 3)

**Detect what changed in spec:**

```python
def detect_spec_changes(old_spec, new_spec):
    """
    Compare specs and return what changed

    Returns:
        {
            "added_agents": ["hotel_agent"],
            "removed_agents": [],
            "modified_agents": ["flight_agent"],
            "added_tools": ["hotel_api"],
            "schema_version_changed": True
        }
    """
    changes = {
        "added_agents": [],
        "removed_agents": [],
        "modified_agents": [],
        "added_tools": [],
        "removed_tools": [],
        "schema_version_changed": False
    }

    # Compare agents
    old_agents = set(old_spec.get("agents", {}).keys())
    new_agents = set(new_spec.get("agents", {}).keys())

    changes["added_agents"] = list(new_agents - old_agents)
    changes["removed_agents"] = list(old_agents - new_agents)

    # Check for modified agents
    for agent in old_agents & new_agents:
        if old_spec["agents"][agent] != new_spec["agents"][agent]:
            changes["modified_agents"].append(agent)

    # Similar for tools, schema_version, etc.

    return changes
```

### Stage 3: Selective Regeneration (Day 4)

**Update generators to support incremental mode:**

```python
# In generators/agents.py
def generate(spec, out_dir, dry_run=False, incremental=False, manifest=None):
    """
    Generate agent implementations

    Args:
        incremental: If True, only generate new/changed agents
        manifest: GenerationManifest instance
    """

    agents = spec.get("agents", {})

    for agent_name, agent_config in agents.items():
        output_file = agents_dir / f"{agent_name}.py"

        # Skip if file exists and wasn't modified and we're in incremental mode
        if incremental and output_file.exists():
            if not manifest.is_modified(output_file):
                print(f"[agents]   Skipping {agent_name} (unchanged)")
                continue
            else:
                print(f"[agents]   Warning: {agent_name} was modified by user")
                print(f"[agents]   Regenerating {agent_name} (will overwrite changes)")
                # Could prompt user here: overwrite / skip / merge

        # Generate agent (existing code)
        ...
```

## Usage Examples

### Example 1: Initial Generation

```bash
# Generate initial project
./goalgen.py --spec travel_v1.json --out ./my_project

# Creates:
# - All files
# - .goalgen/manifest.json (tracks what was generated)
```

### Example 2: Add New Agent

```bash
# Edit spec: add hotel_agent
vim travel_v2.json

# Incremental update
./goalgen.py --spec travel_v2.json --out ./my_project --incremental

# Output:
# [agents] Skipping supervisor_agent (unchanged)
# [agents] Skipping flight_agent (unchanged)
# [agents] Generating hotel_agent (new)
# [agents]   ✓ langgraph/agents/hotel_agent.py
# [agents]   ✓ Updated langgraph/agents/__init__.py
# [langgraph] Updating quest_builder.py (added hotel_agent node)
```

### Example 3: User Modified File

```bash
# User edited flight_agent.py
# Run incremental update

./goalgen.py --spec travel_v2.json --out ./my_project --incremental

# Output:
# [agents] Warning: flight_agent.py was modified
# [agents] Options:
#   1. Skip (keep your changes)
#   2. Overwrite (lose your changes)
#   3. Merge (advanced)
# Choice: 1
# [agents] Skipping flight_agent (user modified)
```

### Example 4: Force Regenerate

```bash
# Regenerate everything (ignores manifest and user changes)
./goalgen.py --spec travel_v2.json --out ./my_project --force

# Output:
# [agents] Warning: Regenerating all files (--force mode)
# [agents] 3 files will be overwritten (including user changes)
# Continue? (y/N): y
```

## Benefits

✅ **Safe incremental development**
- Add agents without fear
- Preserve custom code
- Clear warnings about conflicts

✅ **Fast iteration**
- Only regenerate what changed
- Skip unchanged files

✅ **Version control friendly**
- Minimal diffs
- Easy to review changes

✅ **Flexible workflows**
- `--incremental` for safety
- `--force` when needed
- `--dry-run` to preview

## Migration Path

**Phase 1 (v0.2.0)**: Add manifest support
- Generate manifest
- No behavior change yet

**Phase 2 (v0.3.0)**: Add `--incremental` flag
- Detect changes
- Skip unchanged files
- Warn about conflicts

**Phase 3 (v1.0.0)**: Smart merging
- AST-based merging for Python files
- JSON merging for configs
- Interactive conflict resolution

---

**Status**: Design complete, implementation needed for v0.2.0
